# üèóÔ∏è Entity System - Complete Technical Explanation

## Table of Contents
1. [Tenant vs Entity - Core Concept](#tenant-vs-entity)
2. [Entity Types Explained](#entity-types)
3. [Entity Structure Building Logic](#structure-building-logic)
4. [Path Generation Algorithm](#path-generation)
5. [Level Calculation](#level-calculation)
6. [Circular Reference Prevention](#circular-reference-prevention)
7. [Complete Flow Examples](#flow-examples)

---

## üè¢ Tenant vs Entity - Core Concept

### **Tenant** - Multi-Tenant Isolation (Horizontal)

**What is it?**
- A **tenant** is a **top-level organization/company** in a multi-tenant SaaS system
- Think of it as a **completely isolated workspace**
- Each tenant's data is **completely separated** from other tenants

**Purpose:**
- **Data Isolation**: Tenant A cannot see Tenant B's data
- **Security Boundary**: Each tenant is a security perimeter
- **Billing Unit**: Subscriptions are per tenant
- **Admin Scope**: TenantAdmin can only manage their own tenant

**Real-World Analogy:**
```
Tenant = Different companies using the same software

üè¢ Tenant: "Acme Corporation" (tenantId: "acme-corp")
   - Has their own entities
   - Has their own users
   - Has their own data

üè¢ Tenant: "TechStart Inc" (tenantId: "techstart-inc")
   - Has their own entities
   - Has their own users  
   - Has their own data

‚ùå Acme Corp CANNOT see TechStart Inc's data
‚ùå TechStart Inc CANNOT see Acme Corp's data
```

**Database Level:**
```typescript
// Every query MUST filter by tenantId
db.entities.find({ tenantId: "acme-corp" })  // Only Acme's entities
db.users.find({ tenantId: "acme-corp" })     // Only Acme's users
```

---

### **Entity** - Organizational Hierarchy (Vertical)

**What is it?**
- An **entity** is an **organizational unit WITHIN a tenant**
- It represents the **internal structure** of the organization
- Entities form a **hierarchical tree** (unlimited depth)

**Purpose:**
- **Organizational Structure**: Model real company structure
- **User Assignment**: Users belong to specific entities
- **Access Control**: Permissions based on entity hierarchy
- **Reporting**: Group data by department/company/division

**Real-World Analogy:**
```
Entity = Departments/Teams within a company

Within Tenant "Acme Corporation":
üè¢ Root Entity: "Acme HQ"
   ‚îú‚îÄ‚îÄ üè¢ Company: "North America Division"
   ‚îÇ   ‚îú‚îÄ‚îÄ üë• Department: "Sales"
   ‚îÇ   ‚îú‚îÄ‚îÄ üë• Department: "Marketing"
   ‚îÇ   ‚îî‚îÄ‚îÄ üë• Department: "Engineering"
   ‚îÇ       ‚îú‚îÄ‚îÄ üë• Team: "Backend Team"
   ‚îÇ       ‚îî‚îÄ‚îÄ üë• Team: "Frontend Team"
   ‚îî‚îÄ‚îÄ üè¢ Company: "Europe Division"
       ‚îî‚îÄ‚îÄ üë• Department: "Operations"
```

**Key Difference:**

| Aspect | Tenant | Entity |
|--------|--------|--------|
| **Scope** | Entire organization | Department/Team within org |
| **Isolation** | Complete data separation | Hierarchical within tenant |
| **Storage** | String ID (`tenantId: "acme-corp"`) | MongoDB ObjectId reference |
| **Relationship** | Independent (no parent) | Tree structure (has parent) |
| **Purpose** | Multi-tenancy | Organization structure |
| **User sees** | Only their tenant | Entities they have access to |

---

## üìä Entity Types Explained

The system defines 3 entity types (Line 6-10 in `entity.schema.ts`):

```typescript
export enum EntityType {
  ENTITY = 'entity',      // Root/High-level organization
  COMPANY = 'company',    // Business unit/Division
  DEPARTMENT = 'department', // Team/Department/Section
}
```

### **1. ENTITY Type** üè¢

**Purpose:** Root-level or major organizational unit

**Use Cases:**
- Root entity (no parent)
- Holding company
- Major divisions
- Regional headquarters

**Examples:**
```javascript
{
  name: "Global Headquarters",
  type: "entity",
  parentId: null,           // ‚Üê ROOT ENTITY
  level: 0,
  path: "Global Headquarters"
}

{
  name: "North America Region",
  type: "entity",
  parentId: "hq-id",
  level: 1,
  path: "Global Headquarters > North America Region"
}
```

**Characteristics:**
- ‚úÖ Can be root (parentId = null)
- ‚úÖ Can have unlimited children
- ‚úÖ Usually at higher levels (0-2)
- üéØ Best for: Main organization, regions, major divisions

---

### **2. COMPANY Type** üè¢

**Purpose:** Business unit, subsidiary, or division

**Use Cases:**
- Subsidiary companies
- Business divisions
- Operating units
- Branch offices

**Examples:**
```javascript
{
  name: "Acme Technologies LLC",
  type: "company",
  parentId: "region-id",
  level: 2,
  path: "Global HQ > North America > Acme Technologies LLC"
}

{
  name: "Western Branch",
  type: "company",
  parentId: "company-id",
  level: 3,
  path: "Global HQ > North America > Acme Tech > Western Branch"
}
```

**Characteristics:**
- ‚úÖ Can be root or child
- ‚úÖ Can have unlimited children
- ‚úÖ Usually at mid levels (1-3)
- üéØ Best for: Companies, divisions, branches

---

### **3. DEPARTMENT Type** üë•

**Purpose:** Teams, departments, or working groups

**Use Cases:**
- Functional departments (Sales, Marketing, HR)
- Project teams
- Working groups
- Sub-teams

**Examples:**
```javascript
{
  name: "Sales Department",
  type: "department",
  parentId: "company-id",
  level: 3,
  path: "Global HQ > Acme Tech > Sales Department"
}

{
  name: "Enterprise Sales Team",
  type: "department",
  parentId: "sales-dept-id",
  level: 4,
  path: "Global HQ > Acme Tech > Sales Dept > Enterprise Sales Team"
}
```

**Characteristics:**
- ‚ö†Ô∏è Usually NOT root (but technically can be)
- ‚úÖ Can have children (sub-departments)
- ‚úÖ Usually at deeper levels (2-6+)
- üë§ Users typically assigned here
- üéØ Best for: Departments, teams, groups

---

### **Type Comparison Table:**

| Feature | ENTITY | COMPANY | DEPARTMENT |
|---------|--------|---------|------------|
| Can be root? | ‚úÖ Yes (typical) | ‚ö†Ô∏è Yes (rare) | ‚ö†Ô∏è Yes (rare) |
| Common levels | 0-2 | 1-3 | 2-6+ |
| Has children? | ‚úÖ Yes | ‚úÖ Yes | ‚úÖ Yes |
| Users assigned? | ‚ö†Ô∏è Rare | ‚ö†Ô∏è Sometimes | ‚úÖ Typical |
| Purpose | Structure | Business units | Work groups |
| Icon in UI | üè¢ Purple | üè¢ Blue | üë• Green |

**Important:** These types are **semantic labels** for organization, not hard constraints. The system treats them identically in terms of hierarchy logic.

---

## üîß Entity Structure Building Logic

### **Core Data Structure (Lines 13-52 in entity.schema.ts)**

```typescript
class Entity {
  _id: ObjectId;           // Unique ID (auto-generated)
  name: string;            // Display name
  type: EntityType;        // entity | company | department
  parentId: ObjectId;      // Reference to parent (null = root)
  path: string;            // Full hierarchy path (auto-generated)
  tenantId: string;        // Tenant isolation
  level: number;           // Depth in tree (0 = root)
  metadata: Object;        // Custom data
  isActive: boolean;       // Soft delete flag
  createdBy: string;       // Audit trail
}
```

### **Key Concepts:**

#### **1. Adjacency List Pattern** (Line 23-24)
```typescript
@Prop({ type: Types.ObjectId, ref: 'Entity', default: null })
parentId: Types.ObjectId;  // Self-referencing!
```

**How it works:**
- Each entity stores a **reference to its parent**
- Root entities have `parentId: null`
- Creates a **tree structure** in the database

**Example Data:**
```javascript
// Root
{ _id: "A", name: "HQ", parentId: null }

// Children of A
{ _id: "B", name: "Sales", parentId: "A" }
{ _id: "C", name: "Marketing", parentId: "A" }

// Grandchild of A (child of B)
{ _id: "D", name: "Enterprise Sales", parentId: "B" }
```

**Tree Visualization:**
```
      A (HQ)
     / \
    B   C
   /     
  D      
```

---

#### **2. Path Materialization** (Line 26-27)
```typescript
@Prop({ required: true })
path: string;  // Stores full path for fast queries
```

**Purpose:** Enables fast "get all descendants" queries without recursion

**How it works:**
- Path is **auto-generated** on create/update
- Stores **full hierarchy** as a string
- Separator: `" > "`

**Generation Logic (Lines 215-231):**
```typescript
private async generatePath(name: string, parentId: string | null, tenantId: string): Promise<string> {
  // If no parent ‚Üí this is root
  if (!parentId) {
    return name;  // Root path = just the name
  }

  // Find parent entity
  const parent = await this.entityModel.findOne({
    _id: parentId,
    tenantId,
    isActive: true,
  });

  if (!parent) {
    throw new NotFoundException('Parent entity not found');
  }

  // Concatenate parent's path + current name
  return `${parent.path} > ${name}`;
}
```

**Example Execution:**

```javascript
// Creating entities step by step:

// Step 1: Create root
create({ name: "HQ", parentId: null })
‚Üí path = "HQ"

// Step 2: Create child of HQ
create({ name: "Sales", parentId: "hq-id" })
‚Üí parent.path = "HQ"
‚Üí path = "HQ > Sales"

// Step 3: Create grandchild
create({ name: "Enterprise Team", parentId: "sales-id" })
‚Üí parent.path = "HQ > Sales"
‚Üí path = "HQ > Sales > Enterprise Team"
```

**Benefits:**
- ‚úÖ Fast hierarchy queries: `path LIKE "HQ > Sales%"`
- ‚úÖ No recursion needed to get full path
- ‚úÖ Human-readable in database
- ‚ö†Ô∏è Must update on entity rename/move

---

#### **3. Level Tracking** (Line 32-33)
```typescript
@Prop({ required: true, default: 0 })
level: number;  // Depth in tree (0-based)
```

**Purpose:** Quick depth queries without counting parents

**Calculation Logic (Lines 233-241):**
```typescript
private async calculateLevel(parentId: string, tenantId: string): Promise<number> {
  const parent = await this.entityModel.findOne({
    _id: parentId,
    tenantId,
    isActive: true,
  });

  return parent ? parent.level : 0;
}

// Usage in create (Line 44):
const level = parentId ? await this.calculateLevel(parentId, tenantId) + 1 : 0;
```

**Example:**
```javascript
// Root entity
{ name: "HQ", parentId: null, level: 0 }

// Child (+1 from parent)
{ name: "Sales", parentId: "hq", level: 0 + 1 = 1 }

// Grandchild (+1 from parent)
{ name: "Team A", parentId: "sales", level: 1 + 1 = 2 }

// Great-grandchild (+1 from parent)
{ name: "Squad 1", parentId: "team-a", level: 2 + 1 = 3 }
```

**Benefits:**
- ‚úÖ Filter by depth: `level <= 2` (get only 2 levels)
- ‚úÖ Calculate in O(1) time
- ‚úÖ Useful for UI indentation
- ‚ö†Ô∏è Must update on entity move

---

## üîÑ Complete Creation Flow

### **Creating an Entity (Lines 19-58):**

```typescript
async create(createEntityDto: CreateEntityDto, userId: string): Promise<Entity> {
  const { name, type, parentId, tenantId, metadata } = createEntityDto;

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // STEP 1: Validate Parent (if provided)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  if (parentId) {
    // Check parent exists in same tenant
    const parent = await this.entityModel.findOne({
      _id: parentId,
      tenantId,        // ‚Üê TENANT ISOLATION
      isActive: true,
    });

    if (!parent) {
      throw new NotFoundException('Parent entity not found');
    }

    // Check for circular references
    // (e.g., trying to make parent a child of itself)
    if (await this.wouldCreateCircularReference(parentId, tenantId)) {
      throw new BadRequestException('Cannot create circular reference');
    }
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // STEP 2: Generate Path
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  const path = await this.generatePath(name, parentId, tenantId);
  // Examples:
  // - No parent: "HQ"
  // - With parent: "HQ > Sales > Team A"

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // STEP 3: Calculate Level
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  const level = parentId ? await this.calculateLevel(parentId, tenantId) + 1 : 0;
  // Examples:
  // - Root: 0
  // - Child of root: 1
  // - Grandchild: 2

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // STEP 4: Create Entity
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  const entity = new this.entityModel({
    name,
    type,
    parentId: parentId || null,  // null for root
    path,                         // Auto-generated
    tenantId,                     // Tenant isolation
    level,                        // Auto-calculated
    metadata: metadata || {},
    createdBy: userId,
  });

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // STEP 5: Save to Database
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  return entity.save();
}
```

---

## üîÅ Circular Reference Prevention

### **The Problem:**
```
Entity A ‚Üí Entity B ‚Üí Entity C
                ‚Üì         ‚Üë
                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚ùå CIRCULAR!
```

If we allowed this, we'd have infinite loops when traversing the tree.

### **Prevention Logic (Lines 243-261):**

```typescript
private async wouldCreateCircularReference(
  parentId: string, 
  tenantId: string, 
  excludeId?: string  // For move operations
): Promise<boolean> {
  
  const parent = await this.entityModel.findOne({
    _id: parentId,
    tenantId,
    isActive: true
  });

  if (!parent) {
    return false;  // Parent doesn't exist, no circular ref
  }

  // For move operations: check if new parent is a descendant
  if (excludeId) {
    // Get ALL descendants of the entity being moved
    const descendants = await this.getAllDescendants(excludeId, tenantId);
    
    // If the new parent is in the descendants list ‚Üí CIRCULAR!
    return descendants.some(desc => desc._id.toString() === parentId);
  }

  return false;
}
```

### **Example:**

```javascript
// Current structure:
A (level 0)
‚îî‚îÄ‚îÄ B (level 1)
    ‚îî‚îÄ‚îÄ C (level 2)

// User tries to move A under C
move(entityId: "A", newParentId: "C")

// Check:
descendants of A = [B, C]  // Recursive search
newParentId = "C"
Is "C" in [B, C]? ‚Üí YES! ‚ùå CIRCULAR REFERENCE DETECTED!
```

---

## üì¶ Complete Real-World Example

### **Scenario: Creating a Multi-Level Organization**

```javascript
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// TENANT: Acme Corporation
// tenantId: "acme-corp"
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 1. Create Root Entity
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
POST /api/v1/entities
{
  "name": "Acme Global",
  "type": "entity",
  "parentId": null,  // ‚Üê ROOT
  "tenantId": "acme-corp"
}

Result:
{
  "_id": "A001",
  "name": "Acme Global",
  "type": "entity",
  "parentId": null,
  "path": "Acme Global",  // ‚Üê Generated
  "level": 0,              // ‚Üê Calculated
  "tenantId": "acme-corp"
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 2. Create Company under Root
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
POST /api/v1/entities
{
  "name": "North America Division",
  "type": "company",
  "parentId": "A001",  // ‚Üê Parent is root
  "tenantId": "acme-corp"
}

// Backend processing:
// 1. Find parent: A001 ‚úì
// 2. Generate path: "Acme Global" + " > " + "North America Division"
// 3. Calculate level: 0 + 1 = 1

Result:
{
  "_id": "A002",
  "name": "North America Division",
  "type": "company",
  "parentId": "A001",
  "path": "Acme Global > North America Division",  // ‚Üê Generated
  "level": 1,                                       // ‚Üê Calculated
  "tenantId": "acme-corp"
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 3. Create Department under Company
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
POST /api/v1/entities
{
  "name": "Engineering",
  "type": "department",
  "parentId": "A002",  // ‚Üê Parent is company
  "tenantId": "acme-corp"
}

// Backend processing:
// 1. Find parent: A002 ‚úì (path="Acme Global > North America Division", level=1)
// 2. Generate path: "Acme Global > North America Division" + " > " + "Engineering"
// 3. Calculate level: 1 + 1 = 2

Result:
{
  "_id": "A003",
  "name": "Engineering",
  "type": "department",
  "parentId": "A002",
  "path": "Acme Global > North America Division > Engineering",  // ‚Üê Generated
  "level": 2,                                                     // ‚Üê Calculated
  "tenantId": "acme-corp"
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 4. Create Sub-Department
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
POST /api/v1/entities
{
  "name": "Backend Team",
  "type": "department",
  "parentId": "A003",  // ‚Üê Parent is Engineering
  "tenantId": "acme-corp"
}

Result:
{
  "_id": "A004",
  "name": "Backend Team",
  "type": "department",
  "parentId": "A003",
  "path": "Acme Global > North America Division > Engineering > Backend Team",  // ‚Üê Generated
  "level": 3,                                                                   // ‚Üê Calculated
  "tenantId": "acme-corp"
}
```

### **Final Tree Structure:**

```
üè¢ Acme Global (ENTITY, Level 0)
   ‚îî‚îÄ‚îÄ üè¢ North America Division (COMPANY, Level 1)
       ‚îî‚îÄ‚îÄ üë• Engineering (DEPARTMENT, Level 2)
           ‚îî‚îÄ‚îÄ üë• Backend Team (DEPARTMENT, Level 3)

All belong to tenantId: "acme-corp"
```

---

## üîÑ Moving Entities (Lines 122-159)

### **Move Operation Logic:**

```typescript
async move(id: string, moveEntityDto: MoveEntityDto, userId: string, tenantId: string): Promise<Entity> {
  // Get entity being moved
  const entity = await this.findOne(id, tenantId);
  const { newParentId } = moveEntityDto;

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // STEP 1: Validate New Parent
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  if (newParentId) {
    const newParent = await this.entityModel.findOne({
      _id: newParentId,
      tenantId,
      isActive: true,
    });

    if (!newParent) {
      throw new NotFoundException('New parent entity not found');
    }

    // ‚ö†Ô∏è CRITICAL: Prevent circular references
    if (await this.wouldCreateCircularReference(newParentId, tenantId, id)) {
      throw new BadRequestException('Cannot create circular reference');
    }
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // STEP 2: Calculate New Path & Level
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  const newPath = await this.generatePath(entity.name, newParentId, tenantId);
  const newLevel = newParentId ? await this.calculateLevel(newParentId, tenantId) + 1 : 0;

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // STEP 3: Update Entity
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  await this.entityModel.findByIdAndUpdate(id, {
    parentId: newParentId || null,
    path: newPath,
    level: newLevel,
    updatedBy: userId,
  });

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // STEP 4: Update ALL Descendants
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // This is CRITICAL! When we move an entity,
  // all its children's paths & levels must update
  await this.updateDescendantsPaths(id, tenantId);

  return this.findOne(id, tenantId);
}
```

### **Descendant Update Logic (Lines 280-293):**

```typescript
private async updateDescendantsPaths(entityId: string, tenantId: string): Promise<void> {
  // Get ALL descendants recursively
  const descendants = await this.getAllDescendants(entityId, tenantId);
  
  // For each descendant, recalculate path & level
  for (const descendant of descendants) {
    const newPath = await this.generatePath(
      descendant.name, 
      descendant.parentId?.toString(), 
      tenantId
    );
    const newLevel = await this.calculateLevel(
      descendant.parentId?.toString(), 
      tenantId
    ) + 1;

    await this.entityModel.findByIdAndUpdate(descendant._id, {
      path: newPath,
      level: newLevel,
    });
  }
}
```

### **Example Move Operation:**

```javascript
// Before move:
A (level 0, path: "A")
‚îú‚îÄ‚îÄ B (level 1, path: "A > B")
‚îÇ   ‚îî‚îÄ‚îÄ C (level 2, path: "A > B > C")
‚îî‚îÄ‚îÄ D (level 1, path: "A > D")

// Move B under D:
move(entityId: "B", newParentId: "D")

// After move:
A (level 0, path: "A")
‚îî‚îÄ‚îÄ D (level 1, path: "A > D")
    ‚îî‚îÄ‚îÄ B (level 2, path: "A > D > B")  ‚Üê Updated!
        ‚îî‚îÄ‚îÄ C (level 3, path: "A > D > B > C")  ‚Üê Also updated!

// Notice:
// - B's level: 1 ‚Üí 2
// - B's path: "A > B" ‚Üí "A > D > B"
// - C's level: 2 ‚Üí 3  (cascade!)
// - C's path: "A > B > C" ‚Üí "A > D > B > C"  (cascade!)
```

---

## üéØ Key Takeaways

### **1. Tenant vs Entity:**
```
Tenant (Horizontal Isolation)     Entity (Vertical Hierarchy)
        ‚Üì                                  ‚Üì
[Acme Corp] [TechStart]           Root ‚Üí Company ‚Üí Department ‚Üí Team
     ‚Üì           ‚Üì                   ‚Üì
  Entities    Entities             Users assigned here
  Users       Users
```

### **2. Three Auto-Computed Fields:**
```typescript
parentId     ‚Üí You provide (or null for root)
‚Üì
path         ‚Üí Auto-generated recursively
level        ‚Üí Auto-calculated from parent
tenantId     ‚Üí You provide (for isolation)
```

### **3. Data Structure Pattern:**
- **Adjacency List**: Each entity stores `parentId`
- **Path Materialization**: Full path stored for performance
- **Level Denormalization**: Depth stored for quick queries

### **4. Safety Mechanisms:**
- ‚úÖ Circular reference prevention
- ‚úÖ Tenant isolation on every query
- ‚úÖ Cascade updates on move
- ‚úÖ Soft delete (isActive flag)
- ‚úÖ Cannot delete with children/users

---

## üìö Summary

**Tenant:**
- Top-level isolation boundary
- Each customer/organization
- `tenantId: "acme-corp"`

**Entity:**
- Organizational structure within tenant
- Hierarchical tree (unlimited depth)
- Types: entity, company, department (semantic labels)

**Structure Building:**
- Self-referencing via `parentId`
- Auto-generated `path` for fast queries
- Auto-calculated `level` for depth tracking
- Circular reference prevention
- Cascade updates on move operations

**Every entity has:**
- Unique ID
- Name & type
- Parent reference (null for root)
- Full path (auto-generated)
- Level depth (auto-calculated)
- Tenant isolation (always filtered)

This design enables **unlimited organizational flexibility** while maintaining **performance and data integrity**! üöÄ

